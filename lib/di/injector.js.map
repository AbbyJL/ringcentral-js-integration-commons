{"version":3,"sources":["lib/di/injector.js"],"names":["REDUCER_LITERAL","PROXY_REDUCER_LITERAL","STATE_FUNC_LITERAL","PROXY_STATE_FUNC_LITERAL","Injector","targetClass","parentInjector","moduleRegistry","providerRegistry","container","universalProviders","provider","pending","localHas","token","has","useExisting","add","resolveModuleProvider","get","delete","set","localGet","value","spread","setInstance","deps","map","dep","optional","dependencies","resolveDependencies","factoryProvider","func","call","klass","resolveInheritedDependencies","Klass","instance","resolveModuleFactoryProvider","dependentModuleProvider","resolveModuleProviderForChildren","dependentModule","getInstance","undefined","injector","providerToken","providerInstance","name","bootstrap","RootClass","providersMetadata","resolveInheritedModuleFactory","provide","useValue","private","useClass","useFactory","values","moduleProviders","entries","moduleProvider","reducers","proxyReducers","rootClassInstance","module","addModule","reducer","proxyReducer","_reducer","state","_proxyReducer","lastAction","action","setParent","_bootstrap","clear","reset"],"mappings":"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","file":"injector.js","sourcesContent":["import { combineReducers } from 'redux';\nimport RcModule from '../RcModule';\nimport Container from './container';\nimport Registry from './registry/registry';\nimport { ValueProvider, ClassProvider, ExistingProvider, FactoryProvider } from './provider';\nimport { assert, camelize } from './utils/utils';\nimport { DIError, CircularDependencyError } from './utils/error';\nimport { isObject, isValueProvider, isStaticClassProvider, isExistingProvider, isFactoryProvider } from './utils/is_type';\n\nconst REDUCER_LITERAL = '_reducer';\nconst PROXY_REDUCER_LITERAL = '_proxyReducer';\nconst STATE_FUNC_LITERAL = '_getState';\nconst PROXY_STATE_FUNC_LITERAL = '_getProxyState';\n\n/**\n * Injector is used for injecting providers to modules.\n * Hierarchical provider injection is supported.\n */\nexport class Injector {\n  static pending = new Set();\n\n  constructor() {\n    this.targetClass = null;\n    this.parentInjector = null;\n    this.moduleRegistry = Registry.moduleRegistry;\n    this.providerRegistry = Registry.providerRegistry;\n    this.container = new Container();\n    this.universalProviders = new Map();\n  }\n\n  /**\n   * Resolve module providers recursively.\n   * May search for providers in parent injector.\n   * @param {Provider} provider\n   * @param {Set} pending - process record\n   */\n  resolveModuleProvider(provider, pending = Injector.pending) {\n    const container = this.container;\n    assert(provider, 'Expected valid provider', provider);\n\n    // Provider has already been resolved\n    if (container.localHas(provider.token)) return;\n\n    // useExisting provider needs to resolve existing providers instead of itself\n    if (provider instanceof ExistingProvider) {\n      if (pending.has(provider)) {\n        throw CircularDependencyError(pending, provider.token);\n      }\n      if (this.universalProviders.has(provider.useExisting)) {\n        pending.add(provider);\n        this.resolveModuleProvider(this.universalProviders.get(provider.useExisting));\n        pending.delete(provider);\n      }\n      if (container.localHas(provider.useExisting)) {\n        container.set(provider.token, container.localGet(provider.useExisting));\n      } else {\n        throw DIError(`ExistingProvider [${provider.useExisting}] is not found`);\n      }\n      return;\n    }\n\n    // If provider exists in ancestor injectors,\n    // then it should create a reference to that provider locally.\n    if (container.has(provider.token)) {\n      container.set(provider.token, container.get(provider.token));\n      return;\n    }\n    if (!this.universalProviders.has(provider.token)) {\n      if (this.parentInjector) {\n        this.parentInjector.resolveModuleProvider(provider);\n      }\n    }\n    if (provider instanceof ValueProvider) {\n      // TODO: this can be optimized to use properties to track the spread flag\n      // so that we don't need to create a new object for spread feature\n      const value = provider.spread\n        ? { value: provider.value, spread: provider.spread }\n        : provider.value;\n      provider.setInstance(value);\n      container.set(provider.token, provider);\n    } else if (provider instanceof FactoryProvider) {\n      pending.add(provider.token);\n      // eslint-disable-next-line\n      const deps = provider.deps.map(dep => isObject(dep) ? dep : { dep, optional: false });\n      const dependencies = this.resolveDependencies(deps, pending);\n      const factoryProvider = provider.func.call(null, dependencies);\n      provider.setInstance(factoryProvider);\n      container.set(provider.token, provider);\n      pending.delete(provider.token);\n    } else if (provider instanceof ClassProvider) {\n      if (this.moduleRegistry.has(provider.klass)) {\n        const deps = Registry.resolveInheritedDependencies(provider.klass) || [];\n        const Klass = provider.klass;\n        pending.add(provider.token);\n        const dependencies = this.resolveDependencies(deps, pending);\n        const instance = new Klass(dependencies);\n        provider.setInstance(instance);\n        container.set(provider.token, provider);\n        pending.delete(provider.token);\n      } else if (\n        provider instanceof ClassProvider &&\n        this.providerRegistry.has(provider.klass)\n      ) {\n        // Depends on moduleFactory provider\n        this.resolveModuleFactoryProvider(provider);\n      } else {\n        throw DIError(\n          `Provider [${provider.token}] can not be resolved, module is not found`\n        );\n      }\n    }\n  }\n\n  /**\n   * Resolve module dependencies recursively.\n   * If module is not optional and can not be resolved, then DIError will be thrown\n   * @param {Array} deps - module dependencies\n   * @param {Set} pending - process record\n   */\n  resolveDependencies(deps, pending) {\n    const dependencies = {};\n    for (const { dep, optional } of deps) {\n      if (pending.has(dep)) {\n        throw CircularDependencyError(pending, dep);\n      }\n      if (!this.container.has(dep)) {\n        if (this.universalProviders.has(dep)) {\n          const dependentModuleProvider = this.universalProviders.get(dep);\n          this.resolveModuleProvider(dependentModuleProvider);\n        } else if (this.parentInjector) {\n          // Dependent module provider can not be found locally,\n          // try to resolve provider in ancestor injectors.\n          this.parentInjector.resolveModuleProviderForChildren(dep);\n        }\n      }\n      // If the dependency is optional but Provider is found, then try to inject the dependency.\n      // Otherwise, if provider is not found, then just ignore.\n      // If the dependency is not optional and Provider is found, then try to inject the dependency.\n      // Otherwise, if the Provider is not found, then an Error should be thrown.\n      if (!optional || this.container.has(dep)) {\n        const dependentModule = this.container.get(dep).getInstance();\n\n        // Value dependency and use spread, in this case, value object needs to be spreaded\n        if (dependentModule.value !== undefined && dependentModule.spread) {\n          Object.assign(dependencies, dependentModule.value);\n        } else {\n          dependencies[camelize(dep)] = dependentModule;\n        }\n      } else if (!optional) {\n        throw DIError(`Dependency Module [${dep}] can not be resolved`);\n      }\n    }\n    // Injector instance will be injected into each module\n    dependencies.injector = this;\n    return dependencies;\n  }\n\n  /**\n   * Resolve a module provider needed by its child providers.\n   * It's a wrapper function only for child injectors.\n   * @param {String} providerToken\n   */\n  resolveModuleProviderForChildren(providerToken) {\n    if (this.universalProviders.has(providerToken)) {\n      this.resolveModuleProvider(this.universalProviders.get(providerToken));\n    } else if (this.parentInjector) {\n      this.parentInjector.resolveModuleProviderForChildren(providerToken);\n    }\n  }\n\n  /**\n   * Used for resolving ModuleFactory provider specifically.\n   * @param {Provider} providerInstance\n   */\n  resolveModuleFactoryProvider(providerInstance) {\n    if (!this.container.has(providerInstance.token)) {\n      Injector.pending.add(providerInstance.token);\n      // Prevent referencing to itself\n      if (providerInstance.klass === this.targetClass) {\n        throw CircularDependencyError(Injector.pending, this.targetClass.name);\n      }\n      const instance = Injector.bootstrap(providerInstance.klass, this);\n      providerInstance.setInstance(instance);\n      this.container.set(\n        providerInstance.token,\n        providerInstance\n      );\n      Injector.pending.delete(providerInstance.token);\n    }\n  }\n\n  /**\n   * A static wrapper function for supporting hierarchical bootstrap.\n   * @param {Class} RootClas\n   * @param {Injector} parentInjector\n   */\n  static bootstrap(RootClass, parentInjector = null) {\n    const injector = new Injector();\n    if (parentInjector) injector.setParent(parentInjector);\n    return injector._bootstrap(RootClass);\n  }\n\n  /**\n   * To bootstrap module factory and resolve all providers.\n   * @param {Class} RootClass\n   */\n  _bootstrap(RootClass) {\n    this.targetClass = RootClass;\n    // TODO: how to cache root class?\n    if (this.container.localHas(RootClass.name)) {\n      return this.container.localGet(RootClass.name).getInstance();\n    }\n\n    // Implement inheritance for ModuleFactory\n    const providersMetadata = Registry.resolveInheritedModuleFactory(RootClass);\n\n    // Iterate through all provider metadata\n    // Discard providers in parent class overwritten by children\n    const universalProviders = this.universalProviders;\n    for (const provider of providersMetadata) {\n      if (isValueProvider(provider)) {\n        universalProviders.set(\n          provider.provide,\n          new ValueProvider(provider.provide, provider.useValue, provider.spread, provider.private)\n        );\n      } else if (isStaticClassProvider(provider)) {\n        universalProviders.set(\n          provider.provide,\n          new ClassProvider(provider.provide, provider.useClass, provider.deps, provider.private)\n        );\n      } else if (isExistingProvider(provider)) {\n        universalProviders.set(\n          provider.provide,\n          new ExistingProvider(provider.provide, provider.useExisting, provider.private)\n        );\n      } else if (isFactoryProvider(provider)) {\n        universalProviders.set(\n          provider.provide,\n          // eslint-disable-next-line\n          new FactoryProvider(provider.provide, provider.useFactory, provider.deps, provider.private)\n        );\n      } else {\n        throw DIError('Expected valid provider', provider);\n      }\n    }\n\n    // Resolve dependencies and create instances of provides\n    const container = this.container;\n    for (const provider of this.universalProviders.values()) {\n      if (!container.has(provider.provide)) {\n        // Provider is a module factory\n        if (\n          provider instanceof ClassProvider &&\n          this.providerRegistry.has(provider.klass)\n        ) {\n          this.resolveModuleFactoryProvider(provider);\n        } else {\n          this.resolveModuleProvider(provider);\n        }\n      }\n    }\n\n    const moduleProviders = {};\n    for (const [token, moduleProvider] of container.entries()) {\n      if (!moduleProvider.private) {\n        moduleProviders[camelize(token)] = moduleProvider.getInstance();\n      }\n    }\n\n    // Instantiate root module\n    const reducers = {};\n    const proxyReducers = {};\n    const rootClassInstance = new RootClass(moduleProviders);\n\n    // Register all module providers to root instance\n    for (const name of Object.keys(moduleProviders)) {\n      const module = moduleProviders[name];\n      if (rootClassInstance instanceof RcModule) {\n        rootClassInstance.addModule(name, module);\n      }\n      if (module.reducer) {\n        reducers[name] = module.reducer;\n      }\n\n      if (module.proxyReducer) {\n        proxyReducers[name] = module.proxyReducer;\n      }\n\n      // Additional module configurations\n      // Do things like reducer registration, getState injection\n      if (module instanceof RcModule) {\n        if (module._reducer) {\n          Object.defineProperty(module, STATE_FUNC_LITERAL, {\n            value: () => rootClassInstance.state[name]\n          });\n        }\n        if (module._proxyReducer) {\n          Object.defineProperty(module, PROXY_STATE_FUNC_LITERAL, {\n            value: () => rootClassInstance.state[name]\n          });\n        }\n        Object.defineProperty(rootClassInstance, REDUCER_LITERAL, {\n          value: combineReducers({\n            ...reducers,\n            // eslint-disable-next-line\n            lastAction: (state = null, action) => action\n          })\n        });\n\n        Object.defineProperty(rootClassInstance, PROXY_REDUCER_LITERAL, {\n          value: combineReducers({\n            ...proxyReducers,\n          })\n        });\n      }\n    }\n\n    return rootClassInstance;\n  }\n\n  /**\n   * Get specific provider by injector.\n   * Will search for providers from parentInjector.\n   * @param {String} token\n   */\n  get(token) {\n    return this.container.get(token).getInstance();\n  }\n\n  /**\n   * Set parent injector and parent container.\n   * Construct a tree-like structure for hierarchical injector.\n   * @param {Injector} parentInjector\n   */\n  setParent(parentInjector) {\n    if (parentInjector) {\n      this.container.setParent(parentInjector.container);\n      this.parentInjector = parentInjector;\n    }\n  }\n\n  // TODO: support hierachical reset\n  static reset() {\n    this.pending.clear();\n    Registry.moduleRegistry.reset();\n    Registry.providerRegistry.reset();\n  }\n}\n"]}